#!/usr/bin/env python
# 
# Jonathan Foote
# jmfoote@loyola.edu
#
# WARNING (2014-01-06): this code isn't tested yet
# 
# A quick hack to play with the idea of figuring out who is
# (somewhat) responsible for bugs in a codebase. Like so:
# 1. Find commits with bug fix strings in them
# 2. Figure out what files/lines the bug fix modified
# 3. Determine how was the last person to modify those lines before the bug fix

import subprocess, re, sys, os, json, difflib

log_regex = re.compile("^commit([0-9a-z]{40})body(.*)$")
partial_regex = re.compile("^.*Partial-Bug: #([\d]+).*$")
close_regex = re.compile("^.*Closes-Bug: #([\d]+).*$")

def get_edits(commit):
    '''
    Gets {filepath: [lines]} modified in commit
    '''
    edits = {}

    # get filepath, line_numbers that were changed with the bug fix
    # via: diff bugfix commit with parent and use external diff hack to extract line numbers

    # TODO: the python-based external diff hack below may break if a binary was modified 
    env = os.environ
    env["GIT_EXTERNAL_DIFF"] = "python -c 'import sys, json; print json.dumps([sys.argv[1], open(sys.argv[2]).read(), open(sys.argv[5]).read()])'"
    cmd = ["git", "diff", commit + "^!"]
    try:
        # prints GIT_EXTERNAL_DIFF args as a json string
        # path old-file old-hex old-mode new-file new-hex new-mode
        out = subprocess.check_output(cmd, env=env)
    except subprocess.CalledProcessError as e:
        # diff returns non-zero regularly
        out = e.output
    for line in out.splitlines():
        obj = json.loads(line) 

        # custom diff to get modified line numbers
        path, old_file, new_file = obj
        i = 0
        lines = []
        for diff_out in difflib.ndiff(old_file.splitlines(), new_file.splitlines()):
            if (diff_out[:2] == "+ " or # new line in new file
                diff_out[:2] == "? "):  # helper line
                # don't advance position in old file
                continue
            elif diff_out[:2] == "- ": # modified line in old file
                lines.append(i)
            i += 1

        # store results 
        if lines:
            edits[path] = edits.get(path, []) + lines

    return edits

def get_editor(commit, filepath, line):
    '''
    Returns last editor of filepath in commit
    '''
    out = subprocess.check_output(["git", "blame", "-p", "-L", 
        "%s,%s" % (line, line), filepath, commit])
    author = out.splitlines()[1][len("author "):]
    #print "author", author
    return author

try:
    lines = subprocess.check_output(["git", "log", "--all", "-M", "-C", 
        "--format=commit%Hbody%B"] + sys.argv[1:]).splitlines()
except subprocess.CalledProcessError as e:
    sys.stderr.write(e.output)
    sys.exit(e.returncode)

bugs = {}
i = 0
# 1. Find a commit that has a bug fix
for line in lines:
    m = re.match(log_regex, line)
    if m: # line is a commit
        commit, body = m.groups()
        m = re.match(close_regex, body)
        if m: # commit closes a bug
            bug_id = int(m.groups()[0])
            # 2. Get files + lines that were changed in this fix
            edits = get_edits(commit)

            # 3. Get names of people who edited those lines
            for filepath, mlines in edits.iteritems():
                if not os.path.exists(filepath):
                    # file was deleted in commit?
                    continue
                for mline in mlines:
                    editor = get_editor(commit+"^", filepath, mline)
                    bugs[editor] = bugs.get(editor, []) + [bug_id]
    i += 1
    if i % 1000 == 0:
        print "%d/%d lines of history processed..." % (i, len(lines))

for editor, bug_ids in sorted(bugs.items(), key=lambda i: len(i[1])):
    print editor, ":", len(bug_ids)
    print "\t%s..." % ", ".join(bug_ids[:5])
