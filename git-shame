#!/usr/bin/env python
# 
# Jonathan Foote
# jmfoote@loyola.edu
#
# **** WARNING (2014-01-06) **** 
# This code is untested
# This idea may be crackheaded; this is just a toy
# ********
# 
# A quick hack to play with the idea of figuring out who is
# (somewhat) responsible for bugs in a codebase. Like so:
# 1. Find commits with bug fix strings in them
# 2. Figure out what files/lines the bug fix modified
# 3. Determine who was the last person to modify those lines before the bug fix

import subprocess, re, sys, os, json, difflib

def get_edits(commit):
    '''
    Gets {filepath: [lines]} modified in commit
    '''
    edits = {}

    # get filepath, line_numbers that were changed with the bug fix
    # via: diff bugfix commit with parent and use external diff hack to extract line numbers

    # TODO: the python-based external diff hack below may break if a binary was modified 
    env = os.environ
    env["GIT_EXTERNAL_DIFF"] = "python -c 'import sys, json; print json.dumps([sys.argv[1], open(sys.argv[2]).read(), open(sys.argv[5]).read()])'"
    cmd = ["git", "diff", commit + "^!"]
    try:
        # prints GIT_EXTERNAL_DIFF args as a json string
        # path old-file old-hex old-mode new-file new-hex new-mode
        out = subprocess.check_output(cmd, env=env)
    except subprocess.CalledProcessError as e:
        # diff returns non-zero regularly
        out = e.output
    for line in out.splitlines():
        obj = json.loads(line) 

        # custom diff to get modified line numbers
        path, old_file, new_file = obj
        i = 1 # line counting starts at 1!
        lines = []
        for diff_out in difflib.ndiff(old_file.splitlines(), new_file.splitlines()):
            if (diff_out[:2] == "+ " or # new line in new file
                diff_out[:2] == "? "):  # helper line
                # don't advance position in old file
                continue
            elif diff_out[:2] == "- ": # modified line in old file
                lines.append(i)
            i += 1

        # store results 
        if lines:
            edits[path] = edits.get(path, []) + lines

    return edits

blame_cache = {}
author_regex = re.compile("^.*\(([^\)]*)[\d]{4}-[\d]{2}-[\d]{2}.*$")
# ^^ first string the left of a date in parens ? :\
def get_editor(commit, filepath, line_num):
    '''
    Returns last editor of line at filepath in commit
    '''

    if (commit, filepath) in blame_cache.keys():
        lines = blame_cache[(commit, filepath)]
    else:
        lines = subprocess.check_output(["git", "blame", filepath, commit]).splitlines()
        blame_cache[(commit, filepath)] = lines
    author = re.match(author_regex, lines[line_num-1]).groups()[0].strip()
    '''
    if len(author) > 30:
        print "FAIL (probably): crappy regex was crappy.."
        print line_num, len(lines)
        print lines[line_num-1]
        print "author", author
    '''
    return author

try:
    commits = subprocess.check_output(["git", "log", "--all", "-M", "-C", 
        "--format=%H"]).splitlines()
except subprocess.CalledProcessError as e:
    sys.stderr.write(e.output)
    sys.exit(e.returncode)

partial_regex = re.compile("^.*Partial-Bug: #([\d]+).*$")
close_regex = re.compile("^.*Closes-Bug: #([\d]+).*$")
# ^^ recommended Gerritt bug-fix strings: 

bugs = {}
bug_editors = {}
i = 0
# 1. Find a commit that has a bug fix
for commit in commits:
    body = subprocess.check_output(["git", "log", "-M", "-C", "-1", "-U", 
        "--name-only", "--format=%B", commit]).replace("\n", " ")
    m = re.match(close_regex, body)
    if m: # commit closes a bug
        bug_id = int(m.groups()[0])
        # 2. Get files + lines that were changed in this fix
        edits = get_edits(commit)

        # 3. Get names of people who edited those lines
        bug_editors[bug_id] = []
        for filepath, mlines in edits.iteritems():
            if not os.path.exists(filepath) or os.path.isdir(filepath):
                # file was deleted in commit?
                continue
            for mline in mlines:
                editor = get_editor(commit+"^", filepath, mline)
                if editor not in bug_editors[bug_id]: # only count editor once per bug
                    bugs[editor] = bugs.get(editor, []) + [(bug_id, commit)]
                    bug_editors[bug_id].append(editor)
                    '''
                    # this describes each blame
                    print "*" * 12
                    print "bug %s fixed in %s: introduced by %s at %s:%s" % \
                            (bug_id, commit, editor, filepath, mline)
                    print "\t", body
                    '''
    i += 1
    if i % 100 == 0:
        print "%d/%d commits processed..." % (i, len(commits))

for editor, bug_data in sorted(bugs.items(), key=lambda i: len(i[1])):
    print editor, ":", len(bug_data)
    '''
    i = 0
    for bug_id, commit in bug_data:
        print "\t%d @ %s" % (bug_id, commit)
        if i > 4:
            print "\t..."
            break
        i += 1
    '''
